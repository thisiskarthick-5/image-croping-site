<!doctype html>
<html lang="en">
<head>
<meta charset="utf-g" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Advanced Image Cropper â€” single file</title>
<style>
  :root {
    --bg-dark: #111827;
    --bg-med: #1f2937;
    --bg-light: #374151;
    --border-color: #4b5563;
    --text-primary: #f9fafb;
    --text-secondary: #9ca3af;
    --accent-primary: #38bdf8;
    --accent-hover: #7dd3fc;
    --shadow-color: rgba(0, 0, 0, 0.2);
    --glass: rgba(255, 255, 255, 0.05);
  }

  html,
  body {
    height: 100%;
    margin: 0;
    font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    background-color: var(--bg-dark);
    color: var(--text-primary);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  .wrap {
    max-width: 1200px;
    margin: 24px auto;
    padding: 24px;
    background-color: var(--bg-med);
    border-radius: 16px;
    border: 1px solid var(--border-color);
    box-shadow: 0 10px 30px var(--shadow-color);
  }

  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    margin-bottom: 24px;
    flex-wrap: wrap;
  }

  header h1 {
    font-size: 22px;
    margin: 0;
    font-weight: 600;
  }

  .tools {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    align-items: center;
  }

  button, select {
    appearance: none;
    border: 1px solid var(--border-color);
    background: var(--bg-light);
    color: inherit;
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    font-weight: 500;
    transition: background-color 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
  }

  button:hover:not(:disabled) {
    background-color: #4b5563;
    border-color: #6b7280;
    transform: translateY(-1px);
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  select {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
    background-position: right 0.5rem center;
    background-repeat: no-repeat;
    background-size: 1.5em 1.5em;
    padding-right: 2.5rem;
  }

  .main {
    display: grid;
    grid-template-columns: 1fr 340px;
    gap: 24px;
  }

  .canvas-wrap {
    background-color: var(--bg-dark);
    border-radius: 12px;
    padding: 16px;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 420px;
    position: relative;
    overflow: hidden;
    border: 1px solid var(--border-color);
  }

  canvas#view {
    max-width: 100%;
    border-radius: 8px;
  }

  .side {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .panel {
    background: var(--bg-light);
    padding: 16px;
    border-radius: 12px;
    border: 1px solid var(--border-color);
  }

  .panel-title {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 12px;
    color: var(--text-primary);
  }

  .row {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
  }
  .row:last-child { margin-bottom: 0; }

  label.small {
    font-size: 14px;
    color: var(--text-secondary);
    min-width: 50px;
  }

  .preset-list {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .preset-list button {
    padding: 8px 12px;
    font-size: 13px;
    background-color: var(--bg-med);
  }

  .preview {
    width: 100%;
    height: 180px;
    background-color: var(--bg-dark);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    border: 1px solid var(--border-color);
    margin-top: 8px;
  }

  img.preview-img {
    max-width: 100%;
    max-height: 100%;
  }

  .handles, .guides {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  .small {
    font-size: 13px;
    color: var(--text-secondary);
  }
  
  input[type=file] { display: none; }

  .file-label {
    border: 2px dashed var(--border-color);
    padding: 8px 16px;
    border-radius: 8px;
    cursor: pointer;
    transition: border-color 0.2s ease, color 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .file-label:hover {
    border-color: var(--accent-primary);
    color: var(--accent-primary);
  }

  .kbd {
    background: var(--bg-dark);
    border-radius: 6px;
    padding: 4px 8px;
    font-family: monospace;
    font-size: 12px;
    border: 1px solid var(--border-color);
  }
  
  .hint {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 12px;
    line-height: 1.5;
  }
  
  .btn-primary {
    background-color: var(--accent-primary);
    color: var(--bg-dark);
    border-color: var(--accent-primary);
    font-weight: 600;
  }
  .btn-primary:hover:not(:disabled) {
    background-color: var(--accent-hover);
    border-color: var(--accent-hover);
    color: var(--bg-dark);
  }

  input[type="number"] {
    background-color: var(--bg-med);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    color: var(--text-primary);
    padding: 8px;
    width: 100%;
    font-size: 13px;
  }
  input[type="number"]:focus {
    outline: 2px solid var(--accent-primary);
    border-color: var(--accent-primary);
  }
  
  /* Custom Slider Styles */
  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 6px;
    background: var(--bg-dark);
    border-radius: 5px;
    outline: none;
    padding: 0;
    margin: 0;
    border: 1px solid var(--border-color);
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid var(--bg-dark);
    transition: background-color 0.2s ease;
  }
  input[type="range"]::-webkit-slider-thumb:hover {
    background: var(--accent-hover);
  }

  input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    border: none;
  }
  input[type="range"]::-moz-range-thumb:hover {
    background: var(--accent-hover);
  }
</style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Advanced image cropper app">
    <header>
      <h1>Advanced Image Cropper</h1>
      <div class="tools" role="toolbar" aria-label="Controls">
        <label class="file-label" id="uploadLabel" tabindex="0" title="Upload image">
          <input id="file" type="file" accept="image/*">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
          Upload Image
        </label>

        <button id="resetBtn" title="Reset transforms"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.5 2v6h6M21.5 22v-6h-6"/><path d="M22 11.5A10 10 0 0 0 3.2 7.2M2 12.5a10 10 0 0 0 18.8 4.2"/></svg></button>
        <button id="undoBtn" title="Undo (Z)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 14H6.83l2.83-2.83L8.25 10 3 15.25l5.25 5.25 1.41-1.41L6.83 16H21z"></path></svg></button>
        <button id="redoBtn" title="Redo (Y)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 14h14.17l-2.83-2.83L15.75 10 21 15.25l-5.25 5.25-1.41-1.41L17.17 16H3z"></path></svg></button>

        <select id="presetSelect" aria-label="Aspect presets">
            <option value="free">Free</option>
            <option value="1:1">1:1</option>
            <option value="16:9">16:9</option>
            <option value="4:3">4:3</option>
            <option value="9:16">9:16</option>
        </select>
        
        <select id="formatSelect" aria-label="Export format">
            <option value="png">PNG</option>
            <option value="jpeg">JPEG (90%)</option>
        </select>

        <button id="downloadBtn" title="Export crop (D)" class="btn-primary">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
          Export
        </button>
      </div>
    </header>

    <div class="main">
      <div class="canvas-wrap" id="canvasWrap" tabindex="0">
        <canvas id="view" width="900" height="600" aria-label="Image preview and crop canvas"></canvas>
        <div class="guides" id="guides" aria-hidden="true"></div>
        <div class="handles" id="handles" aria-hidden="true"></div>
      </div>

      <aside class="side">
        <div class="panel">
            <div class="panel-title">Transform</div>
            <div class="row">
                <label class="small">Zoom</label>
                <input type="range" id="zoom" min="0.1" max="4" step="0.01" value="1" style="flex:1">
                <span id="zoomVal" class="small kbd">100%</span>
            </div>
            <div class="row">
                <label class="small">Rotate</label>
                <input id="angle" type="range" min="-180" max="180" step="1" value="0" style="flex:1">
                <span id="angleVal" class="small kbd">0Â°</span>
            </div>
             <div class="row">
                <label class="small">Adjust</label>
                <button id="rotLeft" title="Rotate Left"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.5 2v6h6M2.66 15.57a10 10 0 1 0 .57-8.38"/></svg></button>
                <button id="rotRight" title="Rotate Right"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6M21.34 15.57a10 10 0 1 1-.57-8.38"/></svg></button>
                <button id="flipH" title="Flip Horizontal"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12h18M8 7l-5 5 5 5M16 17l5-5-5-5"/></svg></button>
                <button id="flipV" title="Flip Vertical"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v18M7 8l5-5 5 5M17 16l-5 5-5-5"/></svg></button>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">Canvas</div>
            <div class="row">
                <label class="small">Guides</label>
                <button id="toggleGrid">Grid</button>
                <button id="toggleMask">Mask</button>
            </div>
            <div class="row">
                <label class="small">Export Size</label>
                <input id="exportW" type="number" value="0" min="0" placeholder="width" style="flex:1">
                <input id="exportH" type="number" value="0" min="0" placeholder="height" style="flex:1">
            </div>
        </div>

        <div class="panel">
          <div class="panel-title">Presets</div>
          <div class="preset-list">
            <button data-aspect="1:1">Square</button>
            <button data-aspect="16:9">16:9</button>
            <button data-aspect="4:3">4:3</button>
            <button data-aspect="9:16">Portrait</button>
            <button data-aspect="free">Free</button>
          </div>
        </div>
        
        <div class="panel">
            <div class="panel-title">Preview</div>
            <div class="preview" id="previewBox"><span class="small">No image loaded</span></div>
            <div class="hint">Tip: Drag crop corners to resize. Use mouse wheel to zoom. Keyboard: arrow keys to nudge, Z undo, Y redo, D export.</div>
        </div>
      </aside>
    </div>
  </div>

<script>
/*
 Advanced single-file cropper
 - Loads image
 - Allows pan/zoom/rotate/flip
 - Crop rectangle with corner handles and move
 - Presets, grid, mask, preview, export
 - Undo/redo (limited)
*/

const fileInput = document.getElementById('file');
const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d', { alpha: true });
const canvasWrap = document.getElementById('canvasWrap');
const previewBox = document.getElementById('previewBox');
const zoomRange = document.getElementById('zoom');
const zoomVal = document.getElementById('zoomVal');
const angleRange = document.getElementById('angle');
const angleVal = document.getElementById('angleVal');
const rotLeft = document.getElementById('rotLeft');
const rotRight = document.getElementById('rotRight');
const flipHBtn = document.getElementById('flipH');
const flipVBtn = document.getElementById('flipV');
const presetButtons = document.querySelectorAll('.preset-list button');
const presetSelect = document.getElementById('presetSelect');
const toggleGridBtn = document.getElementById('toggleGrid');
const toggleMaskBtn = document.getElementById('toggleMask');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const formatSelect = document.getElementById('formatSelect');
const exportW = document.getElementById('exportW');
const exportH = document.getElementById('exportH');

let image = new Image();
let state = {
  loaded:false,
  // transform of image in world coords
  tx: 0, ty: 0, scale: 1, angle: 0, flipH:false, flipV:false,
  // crop rectangle in canvas space {x,y,w,h}
  crop: { x: 80, y: 60, w: 400, h: 300 },
  aspect: null,
  showGrid: false,
  showMask: true
};

// history for undo/redo
const history = { stack: [], pos:-1, max:50 };
function pushHistory() {
  const s = JSON.parse(JSON.stringify(state)); // shallow serialize
  history.pos++;
  history.stack.splice(history.pos);
  history.stack.push(s);
  if(history.stack.length>history.max) history.stack.shift();
  history.pos = history.stack.length-1;
}
function canUndo(){ return history.pos > 0; }
function canRedo(){ return history.pos < history.stack.length-1; }
function undo(){ if(!canUndo()) return; history.pos--; state = cloneState(history.stack[history.pos]); render(); updateUI(); }
function redo(){ if(!canRedo()) return; history.pos++; state = cloneState(history.stack[history.pos]); render(); updateUI(); }
function cloneState(s){ return JSON.parse(JSON.stringify(s)); }

function setAspect(aspectStr){
  if(aspectStr==='free'){ state.aspect = null; return; }
  const [a,b] = aspectStr.split(':').map(Number);
  if(a && b) state.aspect = a/b;
}

function clampCropToCanvas() {
  const c = state.crop;
  c.x = Math.max(0, Math.min(c.x, canvas.width - 8));
  c.y = Math.max(0, Math.min(c.y, canvas.height - 8));
  c.w = Math.max(8, Math.min(c.w, canvas.width - c.x));
  c.h = Math.max(8, Math.min(c.h, canvas.height - c.y));
}

function fitImageToCanvas(img){
  // fit while preserving aspect
  const cw = canvas.width, ch = canvas.height;
  const iw = img.width, ih = img.height;
  const ratio = Math.min(cw / iw, ch / ih);
  state.scale = ratio;
  // center
  state.tx = (cw - iw * ratio) / 2;
  state.ty = (ch - ih * ratio) / 2;
}

// drawing
function clear() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
}
function draw(){
  clear();
  if(!state.loaded) return;
  ctx.save();
  // move to center transform
  ctx.translate(state.tx, state.ty);
  ctx.translate(image.width*state.scale/2, image.height*state.scale/2);
  ctx.rotate(state.angle * Math.PI/180);
  ctx.scale(state.flipH ? -state.scale : state.scale, state.flipV ? -state.scale : state.scale);
  ctx.translate(-image.width/2, -image.height/2);
  ctx.drawImage(image, 0, 0);
  ctx.restore();

  drawOverlay();
  updatePreview();
}
function drawOverlay(){
  const c = state.crop;
  // mask
  if(state.showMask){
    ctx.save();
    ctx.fillStyle = 'rgba(17, 24, 39, 0.7)';
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.rect(c.x, c.y, c.w, c.h);
    ctx.fill('evenodd');
    ctx.restore();
  }

  // border
  ctx.save();
  ctx.strokeStyle = 'var(--accent-primary)';
  ctx.lineWidth = 2;
  ctx.strokeRect(c.x + 1, c.y + 1, c.w-2, c.h-2);

  // rule of thirds grid
  if(state.showGrid){
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    const x1 = c.x + c.w/3, x2 = c.x + 2*c.w/3;
    const y1 = c.y + c.h/3, y2 = c.y + 2*c.h/3;
    ctx.moveTo(x1, c.y); ctx.lineTo(x1, c.y + c.h);
    ctx.moveTo(x2, c.y); ctx.lineTo(x2, c.y + c.h);
    ctx.moveTo(c.x, y1); ctx.lineTo(c.x + c.w, y1);
    ctx.moveTo(c.x, y2); ctx.lineTo(c.x + c.w, y2);
    ctx.stroke();
  }

  // handles
  const handles = getHandles(c);
  ctx.fillStyle = 'var(--text-primary)';
  ctx.strokeStyle = 'var(--bg-dark)';
  ctx.lineWidth = 3;
  handles.forEach(h=>{
    ctx.strokeRect(h.x-6, h.y-6, 12,12);
    ctx.fillRect(h.x-6, h.y-6, 12,12);
  });
  ctx.restore();
}

function updatePreview(){
  previewBox.innerHTML = ''; // clear
  const out = document.createElement('canvas');
  const c = state.crop;
  const ow = Math.max(1, Math.round(c.w));
  const oh = Math.max(1, Math.round(c.h));
  out.width = ow; out.height = oh;
  const octx = out.getContext('2d');
  
  octx.drawImage(canvas, -c.x, -c.y);

  // scale down to fit preview box while preserving aspect
  const imgEl = new Image();
  imgEl.src = out.toDataURL('image/png');
  imgEl.className = 'preview-img';
  previewBox.appendChild(imgEl);
}

// geometry helpers
function getHandles(c){
  const x = c.x, y = c.y, w = c.w, h = c.h;
  return [
    { id:'nw', x: x, y: y },
    { id:'n', x: x + w/2, y: y },
    { id:'ne', x: x + w, y: y },
    { id:'e', x: x + w, y: y + h/2 },
    { id:'se', x: x + w, y: y + h },
    { id:'s', x: x + w/2, y: y + h },
    { id:'sw', x: x, y: y + h },
    { id:'w', x: x, y: y + h/2 }
  ];
}
function hitHandle(pos){
  const handles = getHandles(state.crop);
  for(const h of handles){
    if(Math.abs(pos.x - h.x) <= 8 && Math.abs(pos.y - h.y) <= 8) return h.id;
  }
  if(pos.x > state.crop.x && pos.x < state.crop.x + state.crop.w && pos.y > state.crop.y && pos.y < state.crop.y + state.crop.h) return 'move';
  return null;
}

// pointer interaction
let pointer = { down:false, mode:null, startX:0, startY:0, origCrop:null, origState:null, lastMx:0, lastMy:0 };
function getCanvasPos(ev){
  const rect = canvas.getBoundingClientRect();
  const clientX = ev.clientX ?? (ev.touches && ev.touches[0].clientX);
  const clientY = ev.clientY ?? (ev.touches && ev.touches[0].clientY);
  return { x: clientX - rect.left, y: clientY - rect.top };
}

canvas.addEventListener('pointerdown', (e)=>{
  canvas.setPointerCapture(e.pointerId);
  const pos = getCanvasPos(e);
  const hit = hitHandle(pos);
  pointer.down = true;
  pointer.mode = hit;
  pointer.startX = pos.x; pointer.startY = pos.y;
  pointer.origCrop = Object.assign({}, state.crop);
  pointer.origState = Object.assign({}, state);
  pushHistory();
});

canvas.addEventListener('pointermove', (e)=>{
  if(!pointer.down) return;
  const pos = getCanvasPos(e);
  const dx = pos.x - pointer.startX;
  const dy = pos.y - pointer.startY;

  if(pointer.mode === 'move'){
    state.crop.x = pointer.origCrop.x + dx;
    state.crop.y = pointer.origCrop.y + dy;
    clampCropToCanvas();
  } else if(pointer.mode && pointer.mode !== 'move'){
    // corner handles resize
    let c = pointer.origCrop;
    let newCrop = { x:c.x, y:c.y, w:c.w, h:c.h };
    switch(pointer.mode){
      case 'nw':
        newCrop.x = c.x + dx;
        newCrop.y = c.y + dy;
        newCrop.w = c.w - dx;
        newCrop.h = c.h - dy;
        break;
      case 'n':
        newCrop.y = c.y + dy; newCrop.h = c.h - dy; break;
      case 'ne':
        newCrop.y = c.y + dy; newCrop.w = c.w + dx; newCrop.h = c.h - dy; break;
      case 'e':
        newCrop.w = c.w + dx; break;
      case 'se':
        newCrop.w = c.w + dx; newCrop.h = c.h + dy; break;
      case 's':
        newCrop.h = c.h + dy; break;
      case 'sw':
        newCrop.x = c.x + dx; newCrop.w = c.w - dx; newCrop.h = c.h + dy; break;
      case 'w':
        newCrop.x = c.x + dx; newCrop.w = c.w - dx; break;
    }
    // enforce min size
    newCrop.w = Math.max(8, newCrop.w);
    newCrop.h = Math.max(8, newCrop.h);

    // aspect lock
    if(state.aspect){
      const currentAspect = newCrop.w / newCrop.h;
      if(['n', 's'].includes(pointer.mode)) {
        newCrop.w = newCrop.h * state.aspect;
      } else if(['e', 'w'].includes(pointer.mode)) {
        newCrop.h = newCrop.w / state.aspect;
      } else if(['nw', 'ne', 'sw', 'se'].includes(pointer.mode)) {
         if (currentAspect > state.aspect) {
            newCrop.w = newCrop.h * state.aspect;
        } else {
            newCrop.h = newCrop.w / state.aspect;
        }
      }
      
      // Adjust position based on handle
      if(pointer.mode.includes('n')) newCrop.y = c.y + c.h - newCrop.h;
      if(pointer.mode.includes('w')) newCrop.x = c.x + c.w - newCrop.w;
    }

    // commit
    state.crop = newCrop;
    clampCropToCanvas();
  }
  render();
});

window.addEventListener('pointerup', (e)=>{
  if(!pointer.down) return;
  pointer.down = false;
  pointer.mode = null;
  updateUI();
});

canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const delta = Math.sign(e.deltaY);
  // zoom toward center
  state.scale *= (delta>0?0.95:1.05);
  state.scale = Math.max(0.05, Math.min(8, state.scale));
  zoomRange.value = state.scale;
  zoomVal.textContent = Math.round(state.scale*100) + '%';
  render();
});

// touch gestures: simple pinch to zoom
let touchState = { lastDist:0, lastAngle:0 };
canvas.addEventListener('touchstart', (e)=>{
  if(e.touches.length===2){
    e.preventDefault();
    const d = distBetween(e.touches[0], e.touches[1]);
    touchState.lastDist = d;
    touchState.lastAngle = angleBetween(e.touches[0], e.touches[1]);
    pushHistory();
  }
});
canvas.addEventListener('touchmove', (e)=>{
  if(e.touches.length===2){
    e.preventDefault();
    const d = distBetween(e.touches[0], e.touches[1]);
    const ang = angleBetween(e.touches[0], e.touches[1]);
    const factor = d / touchState.lastDist;
    state.scale *= factor;
    const dAngle = (ang - touchState.lastAngle);
    state.angle += dAngle;
    touchState.lastDist = d;
    touchState.lastAngle = ang;
    zoomRange.value = state.scale;
    angleRange.value = state.angle;
    updateUI();
    render();
  }
});
function distBetween(a,b){
  return Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
}
function angleBetween(a,b){
  return Math.atan2(b.clientY-a.clientY, b.clientX-a.clientX) * 180/Math.PI;
}

// UI wiring
fileInput.addEventListener('change', async (e)=>{
  const file = e.target.files[0];
  if(!file) return;
  const url = URL.createObjectURL(file);
  await loadImage(url);
  URL.revokeObjectURL(url);
});

// drag & drop
['dragenter','dragover','dragleave','drop'].forEach(ev=>{
  canvasWrap.addEventListener(ev, (e)=>{
    e.preventDefault();
    e.stopPropagation();
  });
});
canvasWrap.addEventListener('drop', async (e)=>{
  const f = e.dataTransfer.files && e.dataTransfer.files[0];
  if(f && f.type.startsWith('image/')){
    const url = URL.createObjectURL(f);
    await loadImage(url);
    URL.revokeObjectURL(url);
  }
});

async function loadImage(src){
  return new Promise((res,rej)=>{
    const img = new Image();
    img.onload = ()=>{
      image = img;
      state.loaded = true;
      fitImageToCanvas(image);
      // default crop centered
      state.crop = { x: canvas.width*0.08, y: canvas.height*0.08, w: canvas.width*0.84, h: canvas.height*0.84 };
      setAspect(presetSelect.value);
      pushHistory();
      render();
      updateUI();
      res();
    };
    img.onerror = rej;
    img.src = src;
  });
}

zoomRange.addEventListener('input', (e)=>{
  state.scale = parseFloat(e.target.value);
  zoomVal.textContent = Math.round(state.scale*100) + '%';
  render();
});

angleRange.addEventListener('input', (e)=>{
  state.angle = parseFloat(e.target.value);
  angleVal.textContent = Math.round(state.angle) + 'Â°';
  render();
});

rotLeft.addEventListener('click', ()=>{
  state.angle -= 90;
  angleRange.value = state.angle;
  angleVal.textContent = Math.round(state.angle) + 'Â°';
  pushHistory(); render();
});
rotRight.addEventListener('click', ()=>{
  state.angle += 90;
  angleRange.value = state.angle;
  angleVal.textContent = Math.round(state.angle) + 'Â°';
  pushHistory(); render();
});
flipHBtn.addEventListener('click', ()=>{ state.flipH = !state.flipH; pushHistory(); render(); });
flipVBtn.addEventListener('click', ()=>{ state.flipV = !state.flipV; pushHistory(); render(); });

presetButtons.forEach(b=>{
  b.addEventListener('click', ()=>{ 
    presetSelect.value = b.dataset.aspect; 
    setAspect(b.dataset.aspect); 
    // Recalculate crop for new aspect ratio, centered
    const c = state.crop;
    const centerX = c.x + c.w / 2;
    const centerY = c.y + c.h / 2;
    if (state.aspect) {
      if (c.w / c.h > state.aspect) { // Crop is wider than target
        c.w = c.h * state.aspect;
      } else { // Crop is taller than or equal to target
        c.h = c.w / state.aspect;
      }
    }
    c.x = centerX - c.w / 2;
    c.y = centerY - c.h / 2;

    clampCropToCanvas();
    render(); 
  });
});
presetSelect.addEventListener('change', (e)=>{ setAspect(e.target.value); render(); });

toggleGridBtn.addEventListener('click', ()=>{ state.showGrid = !state.showGrid; render(); });
toggleMaskBtn.addEventListener('click', ()=>{ state.showMask = !state.showMask; render(); });

resetBtn.addEventListener('click', ()=>{
  if(!state.loaded) return;
  fitImageToCanvas(image);
  state.angle = 0; state.flipH=false; state.flipV=false; state.showGrid=false;
  state.crop = { x: canvas.width*0.08, y: canvas.height*0.08, w: canvas.width*0.84, h: canvas.height*0.84 };
  pushHistory();
  render();
  updateUI();
});

downloadBtn.addEventListener('click', doExport);
undoBtn.addEventListener('click', ()=>{ undo(); });
redoBtn.addEventListener('click', ()=>{ redo(); });

function doExport(){
  if(!state.loaded) return;
  // we will draw to a temp canvas at desired export size
  const c = state.crop;
  const exportWidth = Math.max(0, parseInt(exportW.value) || Math.round(c.w));
  const exportHeight = Math.max(0, parseInt(exportH.value) || Math.round(c.h));
  const tmp = document.createElement('canvas');
  tmp.width = exportWidth; tmp.height = exportHeight;
  const tctx = tmp.getContext('2d');
  
  // draw main canvas segment corresponding to crop stretched to export size
  tctx.drawImage(canvas, c.x, c.y, c.w, c.h, 0, 0, exportWidth, exportHeight);

  const format = formatSelect.value;
  if(format === 'png'){
    tmp.toBlob(blob => {
      downloadBlob(blob, 'crop.png');
    }, 'image/png');
  } else {
    tmp.toBlob(blob => {
      downloadBlob(blob, 'crop.jpg');
    }, 'image/jpeg', 0.9);
  }
}

function downloadBlob(blob, filename){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); document.body.removeChild(a); }, 5000);
}

// keyboard shortcuts
window.addEventListener('keydown', (e)=>{
  if(e.target.tagName === 'INPUT') return; // Don't interfere with typing in number inputs
  if(e.key === 'ArrowLeft'){ state.crop.x -= (e.shiftKey?10:1); clampCropToCanvas(); render(); }
  if(e.key === 'ArrowRight'){ state.crop.x += (e.shiftKey?10:1); clampCropToCanvas(); render(); }
  if(e.key === 'ArrowUp'){ state.crop.y -= (e.shiftKey?10:1); clampCropToCanvas(); render(); }
  if(e.key === 'ArrowDown'){ state.crop.y += (e.shiftKey?10:1); clampCropToCanvas(); render(); }
  if(e.key.toLowerCase() === 'z' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); undo(); }
  if(e.key.toLowerCase() === 'y' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); redo(); }
  if(e.key.toLowerCase() === 'd' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); doExport(); }
});

// render wrapper
function render(){
  requestAnimationFrame(() => {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();

    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    draw();
    updateUI();
  });
}

function updateUI(){
  zoomRange.value = state.scale;
  zoomVal.textContent = Math.round(state.scale*100) + '%';
  angleRange.value = state.angle;
  angleVal.textContent = Math.round(state.angle) + 'Â°';
  undoBtn.disabled = !canUndo();
  redoBtn.disabled = !canRedo();
}

// initial canvas siaze
function init(){
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  render();
  pushHistory();
  updateUI();
  
  window.addEventListener('resize', render);
}
init();

// Allow uploading when clicking the label
document.getElementById('uploadLabel').addEventListener('click', ()=>fileInput.click());
// keyboard accessible upload label press Enter
document.getElementById('uploadLabel').addEventListener('keydown', (e)=>{ if(e.key==='Enter') fileInput.click(); });

</script>
</body>
</html>
